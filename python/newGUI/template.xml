<?xml version="1.0" ?><template><component abstract="False" desc="This components buffers as many packets as the reordering delay and release them we correctly generated DTSs inferred from PTS only streams. This component is only useful when the DTS is corrupted or undefined. CAVEAT: Two packets with the same PTS will cause a RuntuimeError." name="restamp" type="miscellaneous"><param default="2" desc="the maximal reordering delay in packets" name="delay" type="int"/></component><component abstract="False" desc="AMR-WB+ packets are aggregated into packets of (near) MTU size according to RFC 4352" name="AMR-WBP-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="mtu" type="int"/></component><component abstract="False" desc="This component constructs an inter layer bandwidth comparison at the end of a passing svc stream. A 3D graph is constructed with for each layer a cube scaled with the relative weight of the layer in the total bandwidth. The graph is generated as a maple worksheet (\url{www.maplesoft.com})." name="svc-analyzer" type="miscellaneous"><param default="" desc="the path of the maple worksheet with extension .mws" name="filename" type="string"/><param default="1" desc="in how many dimensions to scale the cube (1, 2 or 3)" name="dimension" type="int"/></component><component abstract="False" desc="Joins packets from different sources by only ensuring that the unitnumber rises monotonely." name="unit-multiplexer" type="multiplexer"/><component abstract="True" desc="" name="high-level" type="core"/><component abstract="True" desc="These components transform the received frames for example by transcoding or changing the header format" name="transformer" type="core"/><component abstract="False" desc="Joins packets from different source into a container (no file!) supported by FFMPEG (eg. FLV, WEBM, MP4). The container is released in a stream of MediaPackets containing chunks of the container." name="FFMPEG-multiplexer" type="multiplexer"><param default="262144" desc="in bytes, the maximum size of each chunk" name="chunk-size" type="int"/><param default="flv" desc="format of the container given as file extension (eg. flv, webm, mov, mp4, avi)" name="format" type="string"/><param default="false" desc="if true, disables seeking backwards into the generated chunks" name="streamed" type="bool"/></component><component abstract="False" desc="Listens for incoming RTMPT connections. This is the tunneled version of RTMP." name="RTMPT-server" type="media-server"><param default="80" desc="listen to this port for incoming connections" name="port" type="int"/></component><component abstract="False" desc="AMR and AMR-WB packets are aggregated into packets of (near) MTU size according to RFC 3267" name="AMR-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="mtu" type="int"/><param default="200" desc="in milliseconds, if &gt;= 0, the maximum duration of an aggregate frame, if &lt; 0, omit this requirement" name="maxptime" type="int"/></component><component abstract="False" desc="Requests and receives a stream via RTSP. Generates audio and video frames." name="RTSP-client" type="media-client"/><component abstract="False" desc="This components classifies the many different types of NAL units present in H264, far the beyond the common I, B and P frames." name="avc-classifier" type="classifier"><param default="0" desc="the offset if the media-packet is an I slice" name="I" type="int"/><param default="0" desc="the offset if the media-packet is an SI slice" name="SI" type="int"/><param default="0" desc="the offset if the media-packet is an EI slice" name="EI" type="int"/><param default="0" desc="the offset if the media-packet is an I (data partition B) slice" name="I(B)" type="int"/><param default="0" desc="the offset if the media-packet is an I (data partition C) slice" name="I(C)" type="int"/><param default="0" desc="the offset if the media-packet is a P slice" name="P" type="int"/><param default="0" desc="the offset if the media-packet is an SP slice" name="SP" type="int"/><param default="0" desc="the offset if the media-packet is an EP slice" name="EP" type="int"/><param default="0" desc="the offset if the media-packet is a P (data partition B) slice" name="P(B)" type="int"/><param default="0" desc="the offset if the media-packet is a P (data partition C) slice" name="P(C)" type="int"/><param default="0" desc="the offset if the media-packet is a B slice" name="B" type="int"/><param default="0" desc="the offset if the media-packet is an EB slice" name="EB" type="int"/><param default="0" desc="the offset if the media-packet is a B (data partition B) slice" name="B(B)" type="int"/><param default="0" desc="the offset if the media-packet is a B (data partition C) slice" name="B(C)" type="int"/><param default="0" desc="the offset if the media-packet is a prefix NAL" name="E" type="int"/><param default="0" desc="the offset if the media-packet is a PPS unit" name="PPS" type="int"/><param default="0" desc="the offset if the media-packet is an SPS unit" name="SPS" type="int"/><param default="0" desc="the offset if the media-packet is an extended SPS unit" name="ESPS" type="int"/><param default="0" desc="the offset if the media-packet is a SEI unit" name="SEI" type="int"/><param default="0" desc="the offset if the packet does not belong to any of the above" name="default" type="int"/></component><component abstract="False" desc="Listens for incoming HTTP connections. Does not support pausing or seeking. In the URL use application HTTP for file based transfer of requested file. Use the application FILE@FORMAT (eg. FILE@FLV, FILE@WEBM) to change the container type. Example URLs: \texttt{http://myserver.com/HTTP/demo.mov}, \texttt{http://192.168.1.3/FILE@FLV/demo.mov}" name="HTTP-server" type="media-server"><param default="80" desc="listen to this port for incoming connections" name="port" type="int"/><param default="false" desc="if true, cache generated HLS segments" name="cache" type="bool"/><param default="false" desc="if true, used cached segments and playlists when available" name="cached" type="bool"/><param default="10" desc="in seconds, the duration of one HLS segment" name="segment" type="int"/><param default="1000" desc="in kbit/s, the bitrate of the high quality HLS encoding" name="high" type="int"/><param default="500" desc="in kbit/s, the bit rate of the medium quality HLS encoding" name="medium" type="int"/><param default="200" desc="in kbits/s, the bit rate of low quality HLS encoding" name="low" type="int"/></component><component abstract="True" desc="Schedulers introduce real-time behavior to the stream (readers generate packets at an arbitrary speed). It also introduces correct real-time behavior to streams coming from several receivers. It buffers all incoming packets and releases them at the rate set by the packet's decoding time stamp (DTS). Some schedulers introduce shifts to these time stamps order to obtain for example a smoother bandwidth usage." name="scheduler" type="core"><param default="100" desc="in ms, the scheduler starts working delay ms after the first packet" name="delay" type="int"/><param default="1000" desc="in ms, the size in time of the buffer" name="buffer" type="int"/><param default="0" desc="in ms, start scheduling absolule-delay ms after the start of Sirannon, 0 disables this" name="absolute-delay" type="int"/><param default="false" desc="if true, pause scheduling until the function play is called" name="pause" type="bool"/><param default="1.0" desc="the factor at which to schedule slower or faster than real-time" name="speed" type="double"/><param default="false" desc="if true, run the scheduler in a seperate thread with a quantum of 1 ms for precise timings" name="precise" type="bool"/></component><component abstract="False" desc="This component has a random chance of classifying a packet using a uniform distribution." name="random-classifier" type="classifier"><param default="0.01" desc="$\in[0,1]$, probability to classify the packet" name="P(loss)" type="double"/><param default="0" desc="offset if the condition is met" name="xroute" type="int"/></component><component abstract="True" desc="Transmitters provide the interface to the network for the following protocols: UDP, TCP and RTP/UDP. These components send the packets without any delay or buffering." name="transmitter" type="core"><param default="4000" desc="source port" name="port" type="int"/><param default="127.0.0.1:5000" desc="the IP address of the receiver" name="destination" type="string"/><param default="0" desc="if &gt;0, the size of the protocol buffer, your OS must still accept this value, check 'UDP Buffer Sizing' in Google for more information" name="buffer" type="int"/><param default="false" desc="if true, add an additional header with sirannon frame numbers to the packet, although making it incompatible with a standard player (except for RTP)" name="extension" type="bool"/><param default="-1" desc="the TTL when sending to a multicast destination (not for TCP), -1 disables this" name="multicast-TTL" type="int"/></component><component abstract="False" desc="Requests and receives a stream via HTTP. Demultiplexes the container and generates frames." name="HTTP-client" type="media-client"><param default="" desc="the format of the container, if not defined, guess the format based on the extension in the URL" name="format" type="string"/><param default="false" desc="if true, the URL links to an extended M3U file used by Apple Live HTTP Streaming. The URLs contained in the M3U response will be contacted in turn." name="M3U" type="bool"/></component><component abstract="False" desc="This component classifies or discards every nth frame if 'n % cycle' is non zero. By setting discard to true, this component will essentially discard all but every nth frame." name="count-classifier" type="classifier"><param default="10" desc="do not classify every 'cycle * n'th frame, e.g. if cycle is 10, do not classify frames 0, 10, 20, 30, etc." name="cycle" type="int"/></component><component abstract="False" desc="Drops specific NAL units from an H.264/AVC encoded video stream. The indices of the NAL units to drop are provided in a tracefile. The first NAL unit of the stream has index 1." name="nalu-drop-classifier" type="classifier"><param default="" desc="path to file which contains information on which NAL units to drop. A sample drop-trace file is located in the src/Misc folder." name="drop-trace" type="string"/><param default="false" desc="set to true in case a UDP receiver is used instead of an RTP receiver. Sequence numbers are retained in UDP mode whereas in case of an RTP receiver and transmitter new sequence numbers are generated." name="udpmode" type="bool"/></component><component abstract="False" desc="The fragmented or aggregated frames are transformed again into their original NAL units, as defined in RFC 3984. It performs the reverse operation of the AVC-packetizer." name="AVC-unpacketizer" type="unpacketizer"><param default="true" desc="if true, add startcodes to the unpacked NALs" name="startcodes" type="bool"/><param default="true" desc="if false, all startcodes will be 4 bytes" name="strict-annex-b" type="bool"/></component><component abstract="False" desc="Listens for RTSP connections. Supports pausing, but not seeking." name="RTSP-server" type="media-server"><param default="554" desc="listen to this port for incoming connections" name="port" type="int"/></component><component abstract="False" desc="Handles the mess caused by the MP4 container that strips and merges MP4A and H.264 frames, while TSs and RTP keep the frames in the original format. Reconstructs the header based on the meta data." name="frame-transformer" type="transformer"><param default="true" desc="if true, convert the packets to ES format, if false, convert to MP4 format" name="ES" type="bool"/></component><component abstract="False" desc="Classifies the packets, slice or frames based on fixed indices provided by the user. CAVEAT: Indices must rise strict monotonously; Non slice NAL units such as PPS, SPS, SEI, E, are not counted as slices while different SVC layers are also counted as slices. For example an MVC stream with 4 slices and with 2 layers per frame will be counted as 8 slices." name="fixed-classifier" type="classifier"><param default="frame" desc="whether the indices inputted in values or values-file specify packets, slices or frames, accepted values: frame, slice, packet" name="mode" type="string"/><param default="" desc="if defined, a comma seperated string of indices, indicating which packet, slice or frame to classify counted from 0" name="values" type="string"/><param default="" desc="if defined, a file containing a new line seperated string of indices, indicating which packet, slice or frame to classify counted from 0" name="values-file" type="string"/><param default="1" desc="offset added to the xroute of the packet if the packet is classified" name="xroute" type="int"/></component><component abstract="True" desc="Classifiers add an offset to the xroute of a packet if it meets a certain condition. See section \ref{sec:diff} for an example. Several classifiers can be chained to obtain a more precision classification." name="classifier" type="core"><param default="false" desc="if true, delete the packet instead if the condition is met" name="discard" type="bool"/><param default="" desc="if defined, the path where to log information about the packets entering the classifier" name="sender-trace" type="string"/><param default="" desc="if defined, the path where to log information about the packets exiting the classifier, implies discard is true" name="receiver-trace" type="string"/></component><component abstract="False" desc="Reads in a wide variety of containers supported by ffmpeg. Audio and video are put into different MediaPackets. Per cycle, the reader processes one video frame (if present) and associated audio, possibly generating multiple packets. A separate end- or reset-packet is generated for audio &amp; video. Note, ffmpeg-reader can also process audio only files." name="ffmpeg-reader" type="reader"><param default="true" desc="if true, video will be read from the container, if false video will be ignored" name="video-mode" type="bool"/><param default="true" desc="if true, audio will be read from the container, if false audio will be ignored" name="audio-mode" type="bool"/><param default="-1" desc="in ms, the timestamp to jump to into the stream, -1 implying no seek" name="min-ts" type="int"/><param default="-1" desc="in ms, the maximum timestamp to read from the file, -1 implying no limit" name="max-ts" type="int"/><param default="1000" desc="in ms, specifies the value of the timestamp of the first frame" name="dts-start" type="int"/><param default="true" desc="H.264/AVC only, if true, extract the parameter sets from the container and insert them into the stream" name="add-parameter-sets" type="bool"/><param default="false" desc="H.264/AVC only, if true, repeat the parameter sets before each IDR frame" name="repeat-parameter-sets" type="bool"/><param default="false" desc="MOV/MP4/F4V container only, if true, keep frames in the format of the container, as opposed to annex-B H.264/AVC streams with start codes before each NAL unit" name="mov-frame" type="bool"/><param default="false" desc="if true, remove SEI NALUs from the stream" name="skip-SEI" type="bool"/><param default="false" desc="if true, remove AUD NALUs from the stream" name="skip-AUD" type="bool"/><param default="false" desc="if true, parse H.264 frames to extract the POC from which to calculate the correct PTS" name="fix-PTS" type="bool"/></component><component abstract="False" desc="This component parses elementary MPEG-1, MPEG-2, MPEG-4 or H.264/AVC streams to determine the frame type." name="frame-analyzer" type="miscellaneous"/><component abstract="False" desc="Multiplexes audio and video into an MPEG Transport Stream (TS). CAVEAT: If the video or audio come from different readers, you must set the parameter streams or initial-delay, or the component will throw an error." name="TS-multiplexer" type="multiplexer"><param default="1500" desc="in bytes, the maximum size of an aggregated packet, typically for an iMTU of 1500 it means 7 Transport Stream packets (1370 bytes)" name="mtu" type="int"/><param default="true" desc="if true, several transport stream packets will be aggregated until their size would exceed the iMTU" name="aggregate" type="bool"/><param default="200" desc="in ms, the amount of media to multiplex each pass, this value overwrites the value of delay" name="shape" type="int"/><param default="400" desc="in ms, how much the PCR is in advance of the DTS, the pcr-delay must be lower than the initial DTS of the reader component" name="pcr-delay" type="int"/><param default="-1" desc="in kbps, if -1, no fixed multiplexing rate, if 0, the component will guess the mux rate based on the bitrate of the input, if &gt; 0, use this value as mux-rate" name="mux-rate" type="int"/><param default="true" desc="if true, use the PCR clock as timestamp for the transport stream, if false, use the timestamps of the PCR stream as timestamps for the transport stream" name="continuous-timestamps" type="bool"/><param default="true" desc="if false, all transport stream packets belonging to one frame from a PID are consecutive, if true, they are interleaved with transport stream packets from other PIDs (e.g. audio)" name="interleave" type="bool"/><param default="false" desc="if true, generate an extra PSI triplet (SDT, PAT and PMT) before the start of every key frame of the PCR stream" name="psi-on-key" type="bool"/></component><component abstract="False" desc="Requests and receives a stream via RTMPT. Generates audio and video frames." name="RTMPT-client" type="media-client"><param default="1000" desc="in ms, the time interval between two successive HTTP POSTs during play" name="polling" type="int"/></component><component abstract="False" desc="This component classifies an SVC stream. The partitioning is defined by a series of $(T,D,Q)$ triplets. For each passing NAL unit this series is reverse iterated. If the NAL unit depends on the $n^{th}$ triplet then it is classified as $layer-{n}$. When it didn't depend on any layer it is classified as $layer-{0}$. The triplets are entered in the form of $'T,D,Q:offset'$, for example $'4,0,0:2'$, meaning \textit{'add offset 2 to packets of temporal layer (T) 4 or higher'}." name="svc-classifier" type="classifier"><param default="0" desc="offset for layer 0" name="layer" type="int"/><param default="" desc="definintion and offset for layer 1" name="layer-1" type="string"/><param default="" desc="definintion and offset for layer 2" name="layer-2" type="string"/><param default="" desc="definintion and offset for layer 3" name="layer-3" type="string"/><param default="" desc="definintion and offset for layer 4" name="layer-4" type="string"/><param default="" desc="definintion and offset for layer 5" name="layer-5" type="string"/><param default="" desc="definintion and offset for layer 6" name="layer-6" type="string"/><param default="" desc="definintion and offset for layer 7" name="layer-7" type="string"/></component><component abstract="False" desc="Generates random YUV frames with specified dimensions and/or targetted bitrate." name="fake-reader" type="miscellaneous"><param default="1920" desc="the width of the fake frame" name="width" type="int"/><param default="1080" desc="the height of the fake frame" name="height" type="int"/><param default="12" desc="the number of bits per pixel of the fake frame" name="bits-per-pixel" type="int"/><param default="25." desc="the number of frames per second" name="fps" type="double"/><param default="-1" desc="if defined, overwrite the bitrate implied by the combination of fps and frame dimensions" name="bitrate" type="int"/><param default="-1" desc="in ms, if defined the duration of the sequence, otherwise generate frames indefinately" name="duration" type="int"/><param default="-1" desc="if &gt; 0, divide each frame into packets of maximum mtu size" name="mtu" type="int"/></component><component abstract="False" desc="This component declares a url to be associated with this component and routes to components subscribing to this url" name="out" type="system"><param default="" desc="if defined, links this component with this url, when a new component 'in' is made" name="url" type="string"/></component><component abstract="False" desc="Packetizes MPEG4 audio and video frames into packets suitable for the network as defined in RFC 3640." name="MP4-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="mtu" type="int"/><param default="false" desc="if true, aggregate small packets into one network packet" name="aggregate" type="bool"/></component><component abstract="False" desc="This packetizer produces an RTMP chunk stream from the ingested MediaPackets. Such a stream can directly be sent to a Flash Media Server. Unpacketization of this stream is done by the component RMTP-client internally." name="RTMP-packetizer" type="packetizer"><param default="5" desc="the identifier for this RTMP chunk stream" name="chunk-ID" type="int"/><param default="1" desc="the identifier to which global stream this RTMP chunk stream belongs" name="stream-ID" type="int"/><param default="128" desc="in bytes, the maximum size of each RTMP chunk" name="chunk-size" type="int"/></component><component abstract="True" desc="" name="packetizer" type="core"><param default="" desc="if defined, the path of trace where to log information about the split packets" name="tracefile" type="string"/><param default="false" desc="if true, write the PTS instead of the DTS in the log file" name="trace-pts" type="bool"/></component><component abstract="False" desc="This component finds a component a runtime and creates a route from that component to this. It also buffers the received packets untill the component is scheduled. Using this technique a live captured stream can be tapped into and routed to this component." name="live-reader" type="miscellaneous"><param default="" desc="if defined, create a route from the component out which uses this url" name="url" type="string"/></component><component abstract="False" desc="This simple and generic packetizer can handle any content. However, this packetization is internal to Sirannon and is not recognized by other players. Use sirannon-unpacketizer to unpacketize this stream again." name="sirannon-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="mtu" type="int"/></component><component abstract="False" desc="PES packetization is the required format for transport streams TS-multiplexer. All packets belonging to one frame are aggregated into one PES-packet. If the total size of the frame is larger than 65500 bytes two or more PES-packets are generated unless the option zero-length is set." name="PES-packetizer" type="packetizer"><param default="0" desc="in ms, the amount of time to add to DTS/PTS to make sure is substractable by a PCR" name="delta" type="int"/><param default="false" desc="if true, add AUDs before each H.264 frame" name="insert-AUD" type="bool"/><param default="1" desc="number of audio frames per PES-packet" name="audio-per-PES" type="int"/><param default="true" desc="video only, if true, set 0 as PES-packet-length and generate a single PES-packet per frame" name="zero-length" type="bool"/></component><component abstract="False" desc="Receives RTP streams using the open source library jrtplib. RTCP packets are automatically generated. The additional header is parsed from the RTP header extension if present." name="RTP-receiver" type="receiver"><param default="" desc="if defined, the path of the trace where to log information about the received packets" name="tracefile" type="string"/><param default="8388608" desc="in bytes, the size of the underlyinhg UDP buffer, increase this value when receiving high bitrate streams, make sure yours OS accepts such large values (see \url{http://www.29west.com/docs/THPM/udp-buffer-sizing.html})" name="buffer" type="int"/><param default="" desc="if defined, the path of a file in which the content of a header extension with ID(EXT-HASH: 0xB) is written" name="hash-file" type="string"/></component><component abstract="True" desc="Readers form the primary source of data in the sirannon. When the file reaches its end, a reader either closes the file, generating an end-packet or loops creating a reset-packet. A reader checks if no buffers downstream (typically a scheduler buffer) are full before processing the next frame." name="reader" type="core"><param default="" desc="the path of the file to open" name="filename" type="string"/><param default="1" desc="the number of times to play the video, -1 being infinite, 0 interpreted as 1" name="loop" type="int"/><param default="100" desc="the xroute that will be assigned to packets containing video" name="video-route" type="int"/><param default="200" desc="the xroute that will be assigned to packets containing audio" name="audio-route" type="int"/><param default="1000" desc="in ms, the timestamp that will be added to the DTS &amp; PTS of each frame" name="dts-start" type="int"/></component><component abstract="False" desc="Packetizes AC3 audio frames into packets suitable for RTP as defined in (draft) RFC 4184." name="AC3-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="mtu" type="int"/><param default="true" desc="if true, fill out the header according to the draft version of RFC 4184; this is the version supported by live555/vlc/mplayer" name="draft" type="bool"/></component><component abstract="True" desc="" name="core" type=""><param default="false" desc="if true, print debug info for this component" name="debug" type="bool"/><param default="false" desc="if true, run the component in a seperate thread" name="thread" type="bool"/></component><component abstract="False" desc="Creates a rudimentary video player with no user controls save 'ESC' (which forcibly terminates the video). This component displays immediately any YUV frame it receives. Sirannon must be compiled with the option --with-libSDL to use this component." name="YUV-display" type="miscellaneous"><param default="-1" desc="in pixels, if defined, the width of the video display, otherwise obtain the information from the MediaPackets containing the YUV frames (pPckt-&gt;desc-&gt;width)" name="width" type="int"/><param default="-1" desc="in pixels, if defined, the width of the video display, otherwise obtain the information from the MediaPackets containing the YUV frames (pPckt-&gt;desc-&gt;height)" name="height" type="int"/><param default="false" desc="if true, display the video full screen" name="full-screen" type="bool"/></component><component abstract="False" desc="Writes the content of each received packet to a file and deletes the packet. When an end-packet is received, the file is closed." name="basic-writer" type="writer"><param default="" desc="the path of the file where to write to" name="filename" type="string"/><param default="false" desc="if true, flush the IO buffer after each write" name="flush" type="bool"/><param default="false" desc="if true, after each reset, close the container and open a new container with a name of the form e.g. demo-0.avi, demo-1.avi, demo-2.avi, etc." name="fragmented" type="bool"/><param default="false" desc="if true, if the file is not closed when entering the destructor, delete the file" name="complete" type="bool"/></component><component abstract="False" desc="Decodes received packets and reencodes them using the specified settings. This component runs the transcoding in a seperate thread and may consume all CPU. The component works best effort and can not garantee realtime transcoding." name="transcoder-video" type="transformer"><param default="h264" desc="the target codec" name="output-codec" type="string"/><param default="-1" desc="the target bitrate, -1 implies maintaining the same bitrate" name="bitrate" type="int"/><param default="0" desc="the target width, 0 implies maintaining the same width" name="width" type="int"/><param default="0" desc="the target height, 0 implies maintaining the same height" name="height" type="int"/><param default="-1" desc="the new frame rate which must be less or equal to the current frame rate, -1 implies maintaning the same frame rate" name="framerate" type="int"/><param default="false" desc="if true, generate H.264 in MOV/MP4 frames" name="mov-frame" type="bool"/><param default="" desc="if defined, use specific encoding settings for this target, values: iphone, ipad, youtube" name="target" type="string"/></component><component abstract="False" desc="This components decodes a video sequence and generates a stream of YUV packets" name="ffmpeg-decoder" type="transformer"><param default="true" desc="if true, reset the decoder when a reset-packet is received" name="reset-on-reset" type="bool"/><param default="false" desc="if true, use frame copy as basic error concealment" name="frame-copy" type="bool"/></component><component abstract="False" desc="Packetizes MPEG1&amp;2 audio and video frames into packets suitable for the network as defined in RFC 2250." name="MP2-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="mtu" type="int"/></component><component abstract="False" desc="The packets belonging to a GOP are smoothed in time over the entire duration of that GOP. Caveat, make sure the delay is longer than the duration of one GOP!" name="gop-scheduler" type="scheduler"/><component abstract="True" desc="Media Servers are complex components, listening to a specific TCP port for incoming connections and dynamically creating a session as nested component for each new connection. URLs in the request should be of the form: \texttt{&lt;protocol&gt;://&lt;server-address&gt;/&lt;application&gt;/&lt;media&gt;}. For example \texttt{rtmpt://myserver.com/FILE/flash/example.flv} with server(\texttt{myserver.com}), application(\texttt{FILE}), media(\texttt{flash/example.flv}). Each session creates a nested component of the type \textit{application} given in the URL. Typical applications are FILE, HTTP, RTMP-proxy, RTMPT-proxy, RTSP-proxy, HTTP-proxy." name="media-server" type="core"><param default="" desc="if defined, listen to incoming connections on this specific interface" name="interface" type="string"/><param default="dat/media" desc="path of the folder in which to search for requested files" name="media" type="string"/></component><component abstract="False" desc="When this component receives an end-packet the program will terminate gracefully. In case of both an audio and a video stream, an end-packet for both audio and video needs to be received (if set)." name="sink" type="system"><param default="true" desc="if true, a video end-packet must be received" name="video-mode" type="bool"/><param default="false" desc="if true, an audio end-packet must be received" name="audio-mode" type="bool"/><param default="0" desc="if larger than 0, the number of end-packets which must be received" name="count" type="int"/></component><component abstract="False" desc="For each new stream creates at runtime a fitting packetizer depending on the codec or the parameter type." name="default-packetizer" type="packetizer"><param default="" desc="if defined, force every packetizer to be of this type, useful for forcing PES-packetizer for example" name="type" type="string"/></component><component abstract="False" desc="One or more PES-packets belonging to one frame are split again into the original parts. It performs the reverse operation of the PES-packetizer." name="PES-unpacketizer" type="unpacketizer"/><component abstract="False" desc="" name="AQUA-server" type="private"><param default="8080" desc="the port on which to listen for incoming HTTP requests" name="port" type="int"/><param default="12" desc="the strength of the watermark" name="strength" type="double"/></component><component abstract="False" desc="Monitor for Aqua" name="AQUA-monitor" type="private"><param default="" desc="the yuv-avi with the decoded video" name="media-file" type="string"/><param default="" desc="the watermark extracted by the WM" name="watermark-file" type="string"/><param default="" desc="the hash extracted by the PH" name="hash-file" type="string"/><param default="" desc="the comparison between the WM and the PH" name="ber-file" type="string"/><param default="0.0" desc="the loss chance to determine the scenario in the log" name="loss" type="double"/><param default="10.0" desc="the strength of the watermark" name="strength" type="double"/><param default="true" desc="if true, call the scripts after each reset" name="fragmented" type="bool"/><param default="true" desc="if true, consider watermarking" name="watermark" type="bool"/></component><component abstract="False" desc="Captures packets using a filter and saves those to a file. Uses libpcap for capturing. Needs to have permission to access the interfaces (eg. sudo)." name="PCAP-writer" type="miscellaneous"><param default="eth0" desc="the name of device on which to capture" name="interface" type="string"/><param default="" desc="the path of the file where to write the captured packets" name="filename" type="string"/><param default="" desc="if defined, overwrite the built-in filter" name="filter" type="string"/><param default="1234" desc="the UDP port on which to listen for traffic (when using the built-in filter)" name="port" type="int"/><param default="20" desc="in Mbps, estimated bitrate of stream which determines the underlying buffer size. When unsure of the bitrate, use a royal upper limit. If the debug reports dropped packets, increase this value." name="bitrate" type="int"/></component><component abstract="False" desc="Unpacketizes a stream fragmented by the internal packetizer of Sirannon (sirannon-packetizer)." name="sirannon-unpacketizer" type="unpacketizer"><param default="false" desc="if true, unpacked parts of a damage frame instead of discarding the entire frame" name="recover-frame" type="bool"/><param default="false" desc="if true, throw an exception when packet loss occurs" name="error-on-loss" type="bool"/></component><component abstract="False" desc="Reads in any container in large chunks. Its main use is the HTTP transmission in chunks of a container." name="basic-reader" type="reader"><param default="64000" desc="in bytes, the maximum size of a chunk" name="chunk-size" type="int"/><param default="0" desc="in ms, if &gt; 0, provides the reader with the duration of the file so it can guess the DTS" name="length" type="int"/></component><component abstract="True" desc="Receivers provide the interface from the network for the following protocols: UDP, TCP and RTP/UDP." name="receiver" type="core"><param default="5000" desc="reception port" name="port" type="int"/><param default="100" desc="the xroute that will be assigned to packets containing video" name="video-route" type="int"/><param default="200" desc="the xroute that will be assigned to packets containing audio" name="audio-route" type="int"/><param default="0" desc="if &gt;0, the size of the protocol buffer, your OS must still accept this value, check 'UDP Buffer Sizing' in Google for more information" name="buffer" type="int"/><param default="false" desc="if true, the additional sirannon header is parsed from the packet. Caveat, if the header was not present the stream will be corrupted except for RTP. Conversely, if the header was present and this value is false, the stream will be corrupted except for RTP" name="extension" type="bool"/><param default="false" desc="if true, join a multicast address (not for TCP)" name="multicast" type="bool"/><param default="" desc="multicast address (not for TCP)" name="multicast-server" type="string"/></component><component abstract="False" desc="Any received packet will be deleted." name="discard" type="system"/><component abstract="False" desc="This component takes Sirannon configuration and loads this configuration within itself. It allows grouping of components into one component that can be used in many configurations. Packets are sent to or received from the surrounding scope of the block using the \textit{in} component for input and \textit{out} component for output." name="block" type="system"><param default="" desc="path of the sirannon configuration file" name="config" type="string"/><param default="" desc="if defined, command line parameter 1 for the configuration file" name="param1" type="string"/><param default="" desc="if defined, command line parameter 2 for the configuration file" name="param2" type="string"/><param default="" desc="if defined, command line parameter 3 for the configuration file" name="param3" type="string"/><param default="" desc="if defined, command line parameter 4 for the configuration file" name="param4" type="string"/><param default="" desc="if defined, command line parameter 5 for the configuration file" name="param5" type="string"/><param default="" desc="if defined, command line parameter 6 for the configuration file" name="param6" type="string"/><param default="" desc="if defined, command line parameter 7 for the configuration file" name="param7" type="string"/><param default="" desc="if defined, command line parameter 8 for the configuration file" name="param8" type="string"/><param default="" desc="if defined, command line parameter 9 for the configuration file" name="param9" type="string"/><param default="" desc="if defined, command line parameter 10 for the configuration file" name="param10" type="string"/><param default="" desc="if defined, command line parameter 11 for the configuration file" name="param11" type="string"/><param default="" desc="if defined, command line parameter 12 for the configuration file" name="param12" type="string"/><param default="" desc="if defined, command line parameter 13 for the configuration file" name="param13" type="string"/><param default="" desc="if defined, command line parameter 14 for the configuration file" name="param14" type="string"/><param default="" desc="if defined, command line parameter 15 for the configuration file" name="param15" type="string"/></component><component abstract="True" desc="" name="writer" type="core"/><component abstract="False" desc="Unmultiplexes an MPEG Transport Stream into the original streams each consisting of series of PES-packets. It performs the reverse operation of ts-multiplexer. The MPEG Transport Stream can be as large as entire multi-channel stream." name="TS-demultiplexer" type="demultiplexer"><param default="-1" desc="the selected channel to extract, -1 being all channels" name="channel" type="int"/><param default="100" desc="the xroute that will be assigned to packets containing video" name="video-route" type="int"/><param default="100" desc="the xroute that will be assigned to packets containing audio" name="audio-route" type="int"/></component><component abstract="True" desc="Collection of private components, not for distribution" name="private" type="core"/><component abstract="True" desc="" name="system" type="core"/><component abstract="False" desc="The packets belonging to a frame are smoothed in time over the duration of the frame (instead of sending an entire frame in one burst). Caveat, make sure the delay is longer than the duration of one frame!" name="frame-scheduler" type="scheduler"/><component abstract="False" desc="Basic classifier based solely on the decoding time stamp (DTS) interval, relative to the first packet." name="timestamp-classifier" type="classifier"><param default="0" desc="in DTS clock ($90kHz$), the minimum of the interval" name="start" type="int"/><param default="-1" desc="in DTS clock ($90kHz$), the maximum of the interval, -1 being unlimited" name="stop" type="int"/><param default="1" desc="offset if the condition is met" name="xroute" type="int"/></component><component abstract="False" desc="Reads in an AMR-WB+ encoded sequence in file storage format. The component releases one superframe per packet." name="AMR-WBP-reader" type="reader"/><component abstract="False" desc="This component generates at regular intervals information about the passing stream" name="statistics" type="miscellaneous"><param default="5000" desc="in ms, the amount of time between two reports, -1 disables the reports" name="interval" type="int"/><param default="" desc="if defined, the path where to log information about the passing packets" name="log" type="string"/><param default="" desc="if defined, label used for each entry in the log, this is needed when sending multiple statistics output to one single file" name="label" type="string"/><param default="true" desc="if true, append data to the log, if false, overwrite the log" name="append" type="bool"/><param default="0" desc="the amount of header overhead from network headers to add to the packet size" name="overhead" type="int"/><param default="false" desc="if true, when an end-packet is received, draw a graph of the bandwidth, requires that \textit{log} is defined" name="draw" type="bool"/></component><component abstract="False" desc="Classifies packets based on the type of frame they belong to. The parameter I stands for all sort of I frames (I, IDR, EI, SI...), the same holds for other frame types." name="frame-classifier" type="classifier"><param default="0" desc="the offset if the media-packet is an I slice or frame" name="I" type="int"/><param default="0" desc="the offset if the media-packet is an B slice or frame" name="B" type="int"/><param default="0" desc="the offset if the media-packet is an P slice or frame" name="P" type="int"/><param default="0" desc="the offset if the frame type is none of the above" name="default" type="int"/></component><component abstract="False" desc="Unpacketizes a stream fragmented with MP2 packetization for RTP (RFC 2250) by for example (MP2-packetizer)." name="MP2-unpacketizer" type="unpacketizer"/><component abstract="False" desc="Provides a non-blocking UDP socket to the network." name="UDP-transmitter" type="transmitter"/><component abstract="False" desc="If this component does not receive any packet within a given interval after the last packet, forcibly terminate the program or generate an end-packet." name="time-out" type="system"><param default="1000" desc="in ms, the maximum interval in which no packets are received" name="time-out" type="int"/><param default="true" desc="if true, terminate the program, if false, generate an end-packet" name="kill" type="bool"/></component><component abstract="True" desc="" name="unpacketizer" type="core"/><component abstract="False" desc="Decodes received packets and reencodes them using the specified settings. This component runs the transcoding in a seperate thread and may consume all CPU." name="transcoder-audio" type="transformer"><param default="mp4a" desc="the target codec" name="output-codec" type="string"/><param default="-1" desc="the target bitrate, -1 implies maintaining the same bitrate" name="bitrate" type="int"/><param default="" desc="if defined, use specific encoding settings for this target, values: iphone, ipad, youtube" name="target" type="string"/><param default="200" desc="xroute assigned to the transcoded audio frames" name="route" type="int"/></component><component abstract="False" desc="" name="gigabit-transmitter" type="miscellaneous"><param default="10.10.0.1:1234" desc="the destination" name="destination" type="string"/><param default="4000" desc="the source port" name="port" type="int"/><param default="1450" desc="the size of each generated packet (including headers)" name="mtu" type="int"/><param default="100" desc="in megabits per seconds, bitrate of the generated stream" name="bitrate" type="int"/><param default="25" desc="number of frames per second" name="fps" type="int"/></component><component abstract="False" desc="Joins packets from different sources by only ensuring that the DTS and other timing information rise monotonely. This is a requirement for many protocols and containers." name="std-multiplexer" type="multiplexer"/><component abstract="False" desc="Writes the content of each received packet to a file and deletes the packet. When an end-packet is received, the file is closed." name="AQUA-writer" type="private"><param default="" desc="the name of the yuv file" name="output" type="string"/><param default="" desc="the name of the avi file" name="output-transform" type="string"/><param default="false" desc="if true, flush the IO buffer after each write" name="flush" type="bool"/><param default="false" desc="if true, after each reset, close the container and open a new container with a name of the form e.g. demo-0.avi, demo-1.avi, demo-2.avi, etc." name="fragmented" type="bool"/></component><component abstract="False" desc="Listens for incoming HTTP connections. TO BE FINISHED" name="DIOR-server" type="media-server"><param default="80" desc="listen to this port for incoming connections" name="port" type="int"/></component><component abstract="False" desc="Provides a non-blocking UDP socket from the network." name="UDP-receiver" type="receiver"/><component abstract="False" desc="Example component demonstrating the basic API of a functional component" name="example" type="miscellaneous"><param default="5" desc="input variable" name="test" type="int"/><param default="false" desc="an example flag" name="foo" type="bool"/></component><component abstract="False" desc="" name="qmatch-scheduler" type="scheduler"><param default="false" desc="???" name="interleave1" type="bool"/><param default="false" desc="???" name="interleave2" type="bool"/><param default="false" desc="???" name="interleave3" type="bool"/></component><component abstract="False" desc="Packetizes H264 frames into packets suitable for the network as defined in RFC 3984." name="AVC-packetizer" type="packetizer"><param default="1500" desc="in bytes, the maximum size of a network packet" name="iMTU" type="int"/><param default="false" desc="if true, aggregate small packets into one network packet" name="aggregate" type="bool"/></component><component abstract="False" desc="Provides a non-blocking TCP socket from the network." name="TCP-receiver" type="receiver"><param default="false" desc="if true, connect to the server, if false, listen for an incoming connection" name="connect" type="bool"/></component><component abstract="True" desc="Media Clients connect to servers and retrieve a stream using a particular protocol. The component outputs frames just as would a a Reader component. In this way streams can be requested and captured (using for example \textit{FFMPEG-writer} or \textit{writer}) or resent using a different protocol (for example converting an RTMP stream to a HTTP stream). Proxy applications for Media Servers (RTMP-proxy, RTMPT-proxy, RTSP-proxy, HTTP-proxy) use this feature." name="media-client" type="core"><param default="" desc="the url to retrieve" name="url" type="string"/><param default="true" desc="if true, instantly play the stream" name="auto-play" type="bool"/></component><component abstract="False" desc="This component provides a streaming solution without having to construct a scheme of components. Its many parameters reflect the options of the hidden underlying components (delay, port, destination\textellipsis)." name="streamer" type="high-level"><param default="" desc="the path of the container to stream" name="filename" type="string"/><param default="default" desc="what content to read from the container (video, audio, default)" name="mode" type="string"/><param default="1" desc="the number of times to play the stream, -1 being infinite, 0 interpreted as 1" name="loop" type="int"/><param default="0" desc="the time index to seek to into the container" name="seek" type="int"/><param default="false" desc="option of some packetizers" name="aggregate" type="bool"/><param default="0" desc="delay of the multiplexer, used for transport streams or RTMP" name="multiplexer-delay" type="int"/><param default="basic" desc="which sort of scheduler to use (basic, frame, gop, window)" name="scheduler" type="string"/><param default="1000" desc="in ms, the buffer size in time of the scheduler" name="scheduler-buffer" type="int"/><param default="0" desc="in ms, the delay of the scheduler" name="scheduler-delay" type="int"/><param default="0.0" desc="if larger than 0, randomly lose packets with the give chance" name="loss" type="double"/><param default="rtp" desc="type of the transmitter(rtp, udp, tcp)" name="transmitter" type="string"/><param default="4000" desc="source port of the transmitter" name="port" type="int"/><param default="127.0.0.1:5000" desc="destination of the transmitter" name="destination" type="string"/><param default="false" desc="if true, multiplex the streams into a transport stream" name="ts-mode" type="bool"/><param default="false" desc="if true, muliplex the streams into RTMP chunk streams as output from this component" name="RTMP-mode" type="bool"/><param default="1" desc="streamID used for each RTMP chunk stream" name="RTMP-streamID" type="int"/><param default="7" desc="RTMP chunk stream ID for video" name="RTMP-video-chunkID" type="int"/><param default="6" desc="RTMP chunk stream ID for audio" name="RTMP-audio-chunkID" type="int"/><param default="4096" desc="chunk size for the RTMP chunk streams" name="RTMP-chunk-size" type="int"/></component><component abstract="False" desc="This component finds a component a runtime and creates a route from that component to this. Using this technique a live captured stream can be tapped into and routed to this component." name="in" type="system"><param default="" desc="if defined, create a route from the component 'out' which uses this url" name="url" type="string"/></component><component abstract="False" desc="Simplest form in which the packets are sent at the time solely indicated by the DTS. This leads to a burst of packets for each frame since all the packets have the same DTS." name="basic-scheduler" type="scheduler"/><component abstract="False" desc="Cyclically classifies each GOP by increasing the original xroute, so that xroute cycles through [route,route+split[" name="GOP-splitter" type="miscellaneous"><param default="1" desc="in how many parts to split the stream" name="split" type="int"/><param default="false" desc="if true, drop all frames until the first PPS/SPS/IDR packet" name="sync" type="bool"/></component><component abstract="False" desc="Provides a non-blocking TCP socket to the network." name="TCP-transmitter" type="transmitter"><param default="true" desc="if true, connect to the server, if false, listen for an incoming connection" name="connect" type="bool"/></component><component abstract="False" desc="The packets belonging to one temporal pyramid are smoothed in time over the entire duration of that pyramid. Caveat, make sure the delay is longer than the duration of one pyramid!" name="svc-scheduler" type="scheduler"/><component abstract="False" desc="Requests and receives a stream via HTTP. Keeps the container and generates chunks from it." name="HTTP-capture" type="media-client"><param default="65536" desc="in bytes, the size of the chunks from the container to generate" name="chunk-size" type="int"/></component><component abstract="True" desc="Multiplexers buffer MediaPackets coming from different sources and multiplex those based on the DTS of each MediaPacket. Unmultiplexers perform the reverse operation and restore the original streams." name="multiplexer" type="core"><param default="1000" desc="in ms, the minimal amount of data present for each stream of the multiplex before the next packet is released" name="delay" type="int"/><param default="-1" desc="the number of different streams required before multiplexing, -1 omits this requirement" name="streams" type="int"/></component><component abstract="False" desc="This component has a random chance of classifying a packet using the Gilbert method." name="gilbert-classifier" type="classifier"><param default="0.01" desc="$\in[0,1]$, probability to transit from the GOOD to the BAD state" name="alpha" type="double"/><param default="0.1" desc="$\in[0,1]$, probability to transit from the BAD to the GOOD state" name="beta" type="double"/><param default="0.75" desc="$\in[0,1]$, probability to classify a packet in the BAD state" name="gamma" type="double"/><param default="0.01" desc="$\in[0,1]$, probability to classify a packet in the GOOD state" name="delta" type="double"/><param default="1" desc="offset if the condition is met" name="xroute" type="int"/></component><component abstract="False" desc="Joins packets from different source into a container format supported by FFMPEG (eg. FLV, WEBM, MP4). The container is written to a file." name="ffmpeg-writer" type="writer"><param default="" desc="the path of the file where to write to" name="filename" type="string"/><param default="0" desc="in ms, the minimal delay between the first received packet and first multiplexed packet" name="initial-delay" type="int"/><param default="1000" desc="in ms, the minimal amount of data present for each stream of the multiplex before the next packet is written" name="delay" type="int"/><param default="-1" desc="the number of different streams required before multiplexing, -1 omits this requirement" name="streams" type="int"/><param default="" desc="if defined, overrules the format determined by the extension in the filename" name="format" type="string"/><param default="false" desc="if true, after each reset, close the container and open a new container with a name of the form e.g. demo-0.avi, demo-1.avi, demo-2.avi, etc." name="fragmented" type="bool"/></component><component abstract="True" desc="" name="demultiplexer" type="core"/><component abstract="False" desc="This component ingest a video container and generates a series of transport streams at varies bit rates" name="TS-segmenter" type="high-level"><param default="dat/media" desc="path of the folder in which to search for requested files" name="media" type="string"/><param default="" desc="the path of the container to stream (relative to the folder specified by media)" name="filename" type="string"/><param default="" desc="string indicating the target display (iphone, ipad, youtube)" name="target" type="string"/><param default="10" desc="in seconds the maximum duration of one segment" name="duration" type="int"/><param default="0" desc="in kbps, the 1st bit rate set point, if 0, do not transcode and only segment and do not check for more bitrates" name="bitrate-0" type="int"/><param default="0" desc="the 1st width set point" name="width-0" type="int"/><param default="0" desc="the 1st height set point" name="height-0" type="int"/><param default="0" desc="in kbps, the 2nd bit rate set point, if 0, do not transcode and only segment and do not check for more bitrates" name="bitrate-1" type="int"/><param default="0" desc="the 2nd width set point" name="width-1" type="int"/><param default="0" desc="the 2nd height set point" name="height-1" type="int"/><param default="0" desc="in kbps, the 3rd bit rate set point, if 0, do not transcode and only segment and do not check for more bitrates" name="bitrate-2" type="int"/><param default="0" desc="the 3rd width set point" name="width-2" type="int"/><param default="0" desc="the 3rd height set point" name="height-2" type="int"/></component><component abstract="False" desc="This component is identical to the component FFMPEG-reader, with the exception that the source is not a file but a stream of chunks from a container." name="FFMPEG-demultiplexer" type="demultiplexer"><param default="flv" desc="container format of the input" name="format" type="string"/><param default="32768" desc="amount of bytes fed to the FFMPEG IOContext each time" name="chunk-size" type="int"/><param default="1" desc="the number of times to play the video, -1 being infinite, 0 interpreted as 1" name="loop" type="int"/><param default="100" desc="the xroute that will be assigned to packets containing video" name="videoroute" type="int"/><param default="200" desc="the xroute that will be assigned to packets containing audio" name="audioroute" type="int"/><param default="1000" desc="in ms, the timestamp that will be added to the DTS &amp; PTS of each frame" name="dts-start" type="int"/><param default="true" desc="if true, video will be read from the container, if false video will be ignored" name="video-mode" type="bool"/><param default="true" desc="if true, audio will be read from the container, if false audio will be ignored" name="audio-mode" type="bool"/><param default="-1" desc="in ms, the timestamp to jump to into the stream, -1 implying no seek" name="seek" type="int"/><param default="1000" desc="in ms, specifies the value of the timestamp of the first frame" name="dts-start" type="int"/><param default="true" desc="H.264/AVC only, if true, extract the parameter sets from the container and insert them into the stream" name="add-parameter-sets" type="bool"/><param default="false" desc="H.264/AVC only, if true, repeat the parameter sets before each IDR frame" name="repeat-parameter-sets" type="bool"/><param default="false" desc="MOV/MP4/F4V container only, if true, keep frames in the format of the container, as opposed to annex-B H.264/AVC streams with start codes before each NAL unit" name="mov-frame" type="bool"/><param default="false" desc="if true, remove SEI NALUs from the stream" name="skip-SEI" type="bool"/><param default="false" desc="if true, remove AUD NALUs from the stream" name="skip-AUD" type="bool"/></component><component abstract="True" desc="" name="miscellaneous" type="core"/><component abstract="False" desc="Unpacketizes a stream fragmented with MP4 packetization for RTP (RFC 3640) by for example MP4-packetizer." name="MP4-unpacketizer" type="unpacketizer"/><component abstract="False" desc="The packets are smoothed in time over a fixed non-sliding window. Caveat, make sure the delay is longer than the duration of one window!" name="window-scheduler" type="scheduler"><param default="900" desc="in ms, the size of the fixed window" name="window" type="int"/></component><component abstract="False" desc="Listens for incoming RTMP connections. Supports pausing and seeking. Performs a cryptographical handshake to enable Flash Player to play H.264/AVC and MPEG4-Audio." name="RTMP-server" type="media-server"><param default="1935" desc="listen to this port for incoming connections" name="port" type="int"/></component><component abstract="False" desc="Basic classifier based solely on the real time interval, relative to the first packet. The four time parameters combine to create an interval of the form: $t\in[start,stop[$, when step is defined, it must also hold that: $$t\in\bigcup-{n=1}^{+\infty}[n\cdot step,n\cdot step+delta[$$." name="time-classifier" type="classifier"><param default="0" desc="in ms, the minimum of the range" name="start" type="int"/><param default="-1" desc="in ms, the maximum of the range, -1 being unlimited" name="stop" type="int"/><param default="-1" desc="in ms, the time between two steps, -1 disabling the step effect" name="step" type="int"/><param default="-1" desc="in ms, the duration of one step, -1 being unlimited" name="delta" type="int"/><param default="1" desc="offset if the condition is met" name="xroute" type="int"/></component><component abstract="False" desc="This component does absolutely nothing!" name="dummy" type="system"/><component abstract="False" desc="Provides the RTP/UDP protocol using the open source library jrtplib RTCP packets are automatically generated. The extra information of the sirannon (sirannon-extension) is added as a header extension in RTP packets and this keeps it compatible with a standard player." name="RTP-transmitter" type="transmitter"><param default="false" desc="if true, the streamer uses the PTS of a packet instead of the DTS as time stamp in the RTP header. This can solve the problem where VLC ometimes interprets the RTP timestamp as a PTS instead of a DTS" name="pts" type="bool"/><param default="-1" desc="payload type (PT) of the RTP packets, -1 means leaving the decision to the component" name="payload" type="int"/><param default="" desc="if defined, the path of the trace where to log information about the sent packets" name="tracefile" type="string"/><param default="1500" desc="in bytes, the maximum packet size accepted by the RTP session" name="mtu" type="int"/><param default="false" desc="if true, force the RTP sequence number to follow the unitnumber, hence if you remove packets beforehand, the sequence number will also have gaps, if false, use the default RTP implementation" name="force-sequence-number" type="bool"/></component><component abstract="False" desc="Reads in a raw H264 video file. Each generated \textit{MediaPacket} contains one H.264 NAL-unit, possibly generating multiple \textit{MediaPackets} per frame." name="avc-reader" type="reader"><param default="false" desc="if true, ignore the SEI NAL-units" name="skip-SEI" type="bool"/><param default="false" desc="if true, ignore the AUD NAL-units" name="skip-AUD" type="bool"/><param default="false" desc="if true, convert NAL-units into MP4/MOV/F4V frames" name="mov-frame" type="bool"/></component><component abstract="False" desc="Requests and receives a stream via RTMP. Generates audio and video frames." name="RTMP-client" type="media-client"><param default="false" desc="if true, keep the frames in MOV/MP4 structure for AVC and AAC" name="mov-frame" type="bool"/><param default="65536" desc="in bytes, the size of the chunks from the container to generate" name="chunk-size" type="int"/></component><component abstract="False" desc="Cyclically classifies each time interval by increasing the original xroute, so that xroute cycles through [route,route+split[" name="time-splitter" type="miscellaneous"><param default="1" desc="in how many parts to split the stream" name="split" type="int"/><param default="10000" desc="in ms, the duration of one part" name="interval" type="int"/><param default="false" desc="if true, split only if the frame is a keyframe, if false, omit this condition" name="key" type="bool"/></component><component abstract="False" desc="Unpacketizes an AMR-NB/-WB stream packed according to RFC 3267." name="AMR-unpacketizer" type="unpacketizer"/></template>